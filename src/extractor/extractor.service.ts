import { Injectable } from "@nestjs/common";
import * as puppeteer from "puppeteer";
import {
  MatchResult,
  MatchResultRawData
} from "src/common/interfaces/hearthstone-cards.interface";
import { MatchResultEnum } from "src/game/schemas/game.schema";

@Injectable()
export class ExtractorService {
  async extractJobContent(url: string): Promise<string> {
    if (!url || !url.startsWith("http")) {
      throw new Error("Invalid URL provided.");
    }
    // add autogenerated url from console
    const wsChromeEndpointUrl =
      "ws://127.0.0.1:9222/devtools/browser/94fba52c-d97e-4e23-9f2b-99f3a3a344e7";
    const browser = await puppeteer.connect({
      browserWSEndpoint: wsChromeEndpointUrl
    });
    const page = await browser.newPage();
    try {
      await page.goto(url);
      // Reemplaza uno o mÃ¡s espacios/saltos por un solo espacio, luego trim final.
      const companyName: string | null = await page.evaluate(() => {
        const companyElement = document.querySelector(
          ".job-details-jobs-unified-top-card__company-name"
        );
        let companyRawText = companyElement?.textContent || "";
        companyRawText = companyRawText.replace(/\s+/g, " ").trim();
        return companyRawText;
      });

      const jobTitle: string | null = await page.evaluate(() => {
        const titleElement = document.querySelector(
          ".job-details-jobs-unified-top-card__job-title"
        );
        let titleRawText = titleElement?.textContent || "";
        titleRawText = titleRawText.replace(/\s+/g, " ").trim();
        return titleRawText;
      });

      const jobDetails: string | null = await page.evaluate(() => {
        const jobDetailsElement = document.querySelector("#job-details");
        let jobDetailsRawText = jobDetailsElement?.textContent || "";
        jobDetailsRawText = jobDetailsRawText.replace(/\s+/g, " ").trim();
        return jobDetailsRawText;
      });

      const jobOfferDataString = `Company Name: ${companyName} // Job Title:${jobTitle} // Job Details: ${jobDetails}`;

      return jobOfferDataString;
    } catch (error) {
      await browser.close();
      throw new Error("Error on scrapping webpage", {
        cause: error
      });
    }
  }
  async getMulliganCards(
    matchResultRequest: MatchResultRawData
  ): Promise<MatchResult> {
    const browser = await puppeteer.launch({ headless: false });
    const page = await browser.newPage();
    await page.setViewport({ width: 1280, height: 720 });
    await page.goto(matchResultRequest.matchUrl, { waitUntil: "networkidle0" });
    const content = await page.evaluate(() => {
      const playerDivs = [...document.querySelectorAll("div.player")];

      const myPlayerDiv = playerDivs[1];

      const myCardsSelected = [
        ...myPlayerDiv.querySelectorAll("div.card:not(.mulligan)")
      ];

      const myCardsSelectedNames = myCardsSelected?.map((div) => {
        return div.querySelector("h1")?.textContent;
      }) as string[];

      const myCardsMulligan = [
        ...myPlayerDiv.querySelectorAll("div.card.mulligan")
      ];

      //todo ver como hacer un tipado correcto con esto?
      const myCardsMulliganNames = myCardsMulligan.map((div) => {
        return div.querySelector("h1")?.textContent;
      }) as string[];

      // TURNOS
      const turnElement =
        document.querySelector("dl")?.childNodes[3]?.childNodes[1]?.textContent;

      return {
        numberOfTurns: parseInt(turnElement!),
        initialCardsIds: myCardsSelectedNames,
        discardedCardsIds: myCardsMulliganNames
      };
    });

    const rawHeroesString = await page.$eval(
      "head > meta[name='description']",
      (element) => element.content
    );

    const data = rawHeroesString
      .split(" ")
      .filter((e) => e.includes("("))
      .map((s) => s.replace(/[()]/g, ""))
      .map((s) => s.toUpperCase());

    const payload: MatchResult = {
      numberOfTurns: content.numberOfTurns,
      myClassId: data[0],
      matchResult: matchResultRequest.win
        ? MatchResultEnum.WIN
        : MatchResultEnum.LOSS,
      oponentClassId: data[1],
      mulligan: {
        discardedCardsIds: content.discardedCardsIds,
        initialCardsIds: content.initialCardsIds
      }
    };

    await browser.close();

    return payload;
  }
}
