import { Injectable } from "@nestjs/common";
import * as puppeteer from "puppeteer";
import {
  MatchResultRawData,
  ScrappedMatchResult
} from "src/common/interfaces/hearthstone-cards.interface";
import { MatchResultEnum } from "src/game/schemas/game.schema";

@Injectable()
export class ExtractorService {
  async extractJobContent(url: string): Promise<string> {
    if (!url || !url.startsWith("http")) {
      throw new Error("Invalid URL provided.");
    }
    // add autogenerated url from console
    const wsChromeEndpointUrl =
      "ws://127.0.0.1:9222/devtools/browser/94fba52c-d97e-4e23-9f2b-99f3a3a344e7";
    const browser = await puppeteer.connect({
      browserWSEndpoint: wsChromeEndpointUrl
    });
    const page = await browser.newPage();
    try {
      await page.goto(url);
      // Reemplaza uno o mÃ¡s espacios/saltos por un solo espacio, luego trim final.
      const companyName: string | null = await page.evaluate(() => {
        const companyElement = document.querySelector(
          ".job-details-jobs-unified-top-card__company-name"
        );
        let companyRawText = companyElement?.textContent || "";
        companyRawText = companyRawText.replace(/\s+/g, " ").trim();
        return companyRawText;
      });

      const jobTitle: string | null = await page.evaluate(() => {
        const titleElement = document.querySelector(
          ".job-details-jobs-unified-top-card__job-title"
        );
        let titleRawText = titleElement?.textContent || "";
        titleRawText = titleRawText.replace(/\s+/g, " ").trim();
        return titleRawText;
      });

      const jobDetails: string | null = await page.evaluate(() => {
        const jobDetailsElement = document.querySelector("#job-details");
        let jobDetailsRawText = jobDetailsElement?.textContent || "";
        jobDetailsRawText = jobDetailsRawText.replace(/\s+/g, " ").trim();
        return jobDetailsRawText;
      });

      const jobOfferDataString = `Company Name: ${companyName} // Job Title:${jobTitle} // Job Details: ${jobDetails}`;

      return jobOfferDataString;
    } catch (error) {
      await browser.close();
      throw new Error("Error on scrapping webpage", {
        cause: error
      });
    }
  }

  async getMatchNumberOfTurns(page: puppeteer.Page) {
    const content = await page.evaluate(() => {
      const numberOfTurns =
        document.querySelector("dl")?.childNodes[3]?.childNodes[1]?.textContent;
      return numberOfTurns;
    });

    return { numberOfTurns: parseInt(content!) };
  }

  async getMatchClassId(page: puppeteer.Page) {
    const titulo = await page.title();
    //este es para obtener la clase, pero necesito saber mi nombre de usuario
    const rawHeroesString = await page.$eval(
      "head > meta[name='description']",
      (element) => element.content
    );
    const titleParts = titulo.split("vs.");
    const myUser = titleParts[0];
    const indexOfMyUser = rawHeroesString.indexOf(myUser);
    const textoDespuesDeUsuario = rawHeroesString.substring(
      indexOfMyUser + myUser.length
    );
    const match = textoDespuesDeUsuario.match(/\(([^)]+)\)/);

    return { myClassId: match ? match[1].toUpperCase() : "" };
  }

  async getMatchOponentClassId(page: puppeteer.Page) {
    const rawHeroesString = await page.$eval(
      "head > meta[name='description']",
      (element) => element.content
    );
    const titulo = await page.title();
    const partes = titulo.split("vs.");
    const enemyUser = partes[1].split("-")[0].trim();
    const indexOfenemyUser = rawHeroesString.indexOf(enemyUser);
    const textoDespuesDeUsuarioEnemigo = rawHeroesString.substring(
      indexOfenemyUser + enemyUser.length
    );
    const matchEnemy = textoDespuesDeUsuarioEnemigo.match(/\(([^)]+)\)/);
    return { oponentClassId: matchEnemy ? matchEnemy[1].toUpperCase() : "" };
  }

  getMatchResult(result: boolean) {
    return { matchResult: result ? MatchResultEnum.WIN : MatchResultEnum.LOSS };
  }

  async getMatchMulligan(page: puppeteer.Page) {
    const content = await page.evaluate(() => {
      const playerDivs = [...document.querySelectorAll("div.player")];
      const myPlayerDiv = playerDivs[1];
      const myCardsSelected = [
        ...myPlayerDiv.querySelectorAll("div.card:not(.mulligan)")
      ];
      const myCardsSelectedNames = myCardsSelected?.map((div) => {
        return div.querySelector("h1")?.textContent;
      }) as string[];
      const myCardsMulligan = [
        ...myPlayerDiv.querySelectorAll("div.card.mulligan")
      ];
      const myCardsMulliganNames = myCardsMulligan.map((div) => {
        return div.querySelector("h1")?.textContent;
      }) as string[];

      return {
        initialCardsNames: myCardsSelectedNames,
        discardedCardsNames: myCardsMulliganNames
      };
    });

    const mulligan = {
      initialCardsNames: content.initialCardsNames,
      discardedCardsNames: content.discardedCardsNames
    };

    return mulligan;
  }

  async getMatchDiscardedCardsNames(page: puppeteer.Page) {
    const content = await page.evaluate(() => {
      const playerDivs = [...document.querySelectorAll("div.player")];
      const myPlayerDiv = playerDivs[1];
      const myCardsMulligan = [
        ...myPlayerDiv.querySelectorAll("div.card.mulligan")
      ];
      const myCardsMulliganNames = myCardsMulligan.map((div) => {
        return div.querySelector("h1")?.textContent;
      }) as string[];

      return {
        discardedCardsNames: myCardsMulliganNames
      };
    });

    return { discardedCardNames: content.discardedCardsNames };
  }

  async getMatchInitialCardsNames(page: puppeteer.Page) {
    const content = await page.evaluate(() => {
      const playerDivs = [...document.querySelectorAll("div.player")];
      const myPlayerDiv = playerDivs[1];
      const myCardsSelected = [
        ...myPlayerDiv.querySelectorAll("div.card:not(.mulligan)")
      ];
      const initialCardNames = myCardsSelected?.map((div) => {
        return div.querySelector("h1")?.textContent;
      }) as string[];
      return {
        initialCardNames: initialCardNames
      };
    });

    return { initialCardNames: content.initialCardNames };
  }

  async prepareMatchPayload(
    page: puppeteer.Page,
    matchResultRequest: MatchResultRawData
  ) {
    const numberOfTurns = await this.getMatchNumberOfTurns(page);
    const matchResult = this.getMatchResult(matchResultRequest.win);
    const myClassId = await this.getMatchClassId(page);
    const oponentClassId = await this.getMatchOponentClassId(page);
    const discardedCardsNames = await this.getMatchDiscardedCardsNames(page);
    const initialCardsNames = await this.getMatchInitialCardsNames(page);
    return {
      numberOfTurns,
      matchResult,
      myClassId,
      oponentClassId,
      discardedCardsNames,
      initialCardsNames
    };
  }

  async scrapeMatchUrl(
    matchResultRequest: MatchResultRawData
  ): Promise<ScrappedMatchResult> {
    const browser = await puppeteer.launch({ headless: true });
    const page = await browser.newPage();
    await page.setViewport({ width: 1280, height: 720 });
    await page.goto(matchResultRequest.matchUrl, { waitUntil: "networkidle0" });
    const payload = await this.prepareMatchPayload(page, matchResultRequest);

    return {
      numberOfTurns: payload.numberOfTurns.numberOfTurns,
      myClassId: payload.myClassId.myClassId,
      matchResult: payload.matchResult.matchResult,
      oponentClassId: payload.oponentClassId.oponentClassId,
      discardedCardNames: payload.discardedCardsNames.discardedCardNames,
      initialCardsNames: payload.initialCardsNames.initialCardNames
    };
  }
}
